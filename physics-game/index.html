 <!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Logans Tools For School</title>
  <link rel="icon" type="image/x-icon" href="https://loganstoolsforschool.w3spaces.com/images/images/favicon.png">
  <!-- Comic Neue -->
  <link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@500;700&display=swap" rel="stylesheet"/>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://loganstoolsforschool.w3spaces.com/styles.css">
  <script>
    // Wait for the page to load
window.onload = function() {
  // Keep the loading screen visible for 3 seconds (3000 milliseconds)
  setTimeout(function() {
    // Hide the loading screen
    document.getElementById('loading-screen').style.display = 'none';
    
    // Show the main content
    document.getElementById('main-content').style.display = 'block';
  }, 300);  // Change 3000 to your desired delay in milliseconds
};
</script>
  </head>
  <!-- Loading screen -->
  <div id="loading-screen">
    <img src="https://loganstoolsforschool.w3spaces.com/images/3dgifmaker77391.gif" alt="Loading..." id="loading-image"> <br>
    <h1> Loading...</h1>
  </div>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=10.0">
    <title>2D Physics Simulation</title>
    <style>
        body {
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .controls {
            margin: 0px;
        }

        canvas {
            border: 0px solid black;
        }
    </style>
</head>
<body>
    <div class="controls">
        <button id="reset">Reset</button>
        <label for="colorPicker">Choose Color:</label>
        <input type="color" id="colorPicker" value="#3498db">
        <label for="shapeSelect">Select Shape:</label>
        <select id="shapeSelect">
            <option value="circle">Circle</option>
            <option value="box">Box</option>
            <option value="bomb">Bomb</option>
        </select>
        <label for="heightSlider">Height:</label>
        <input type="range" id="heightSlider" min="10" max="200" value="50">
        <label for="lengthSlider">Length:</label>
        <input type="range" id="lengthSlider" min="10" max="200" value="50">
        <button id="drawToggle">Toggle Draw Mode</button>
    </div>
    <canvas id="simulationCanvas"></canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.17.1/matter.min.js"></script>
    <script>
        const { Engine, Render, World, Bodies, Body, Mouse, MouseConstraint, Constraint, Vector } = Matter;

        const engine = Engine.create();
        const canvas = document.getElementById("simulationCanvas");
        const render = Render.create({
            element: document.body,
            engine: engine,
            canvas: canvas,
            options: {
                width: 800,
                height: 600,
                wireframes: false,
            }
        });

        const mouse = Mouse.create(render.canvas);
        const mouseConstraint = MouseConstraint.create(engine, {
            mouse: mouse,
            constraint: {
                stiffness: 0.2,
                render: { visible: false }
            }
        });
        World.add(engine.world, mouseConstraint);

        canvas.width = 800;
        canvas.height = 600;

        const ground = Bodies.rectangle(400, 590, 810, 60, { isStatic: true });
        World.add(engine.world, ground);

        const resetButton = document.getElementById("reset");
        const colorPicker = document.getElementById("colorPicker");
        const shapeSelect = document.getElementById("shapeSelect");
        const heightSlider = document.getElementById("heightSlider");
        const lengthSlider = document.getElementById("lengthSlider");
        const drawToggle = document.getElementById("drawToggle");

        let drawMode = false;
        let color = colorPicker.value;

        resetButton.addEventListener("click", resetSimulation);
        colorPicker.addEventListener("input", (event) => {
            color = event.target.value;
        });

        shapeSelect.addEventListener("change", () => {
            heightSlider.value = shapeSelect.value === "circle" ? 50 : 100;
            lengthSlider.value = shapeSelect.value === "box" ? 50 : 100;
        });

        canvas.addEventListener("click", (event) => {
            const shape = shapeSelect.value;
            const x = event.clientX - canvas.offsetLeft;
            const y = event.clientY - canvas.offsetTop;

            if (shape === "bomb") {
                const bomb = Bodies.circle(x, y, 20, { render: { fillStyle: "red" } });
                World.add(engine.world, bomb);
                setTimeout(() => explodeBomb(bomb), 3000);
            } else {
                if (drawMode) {
                    if (shape === "circle") {
                        const circle = Bodies.circle(x, y, heightSlider.value / 2, { isStatic: false, render: { fillStyle: color } });
                        World.add(engine.world, circle);
                    } else if (shape === "box") {
                        createBox(x, y);
                    }
                } else {
                    if (shape === "circle") {
                        const circle = Bodies.circle(x, y, heightSlider.value / 2, { render: { fillStyle: color } });
                        World.add(engine.world, circle);
                    } else if (shape === "box") {
                        createBox(x, y);
                    }
                }
            }
        });

        drawToggle.addEventListener("click", () => {
            drawMode = !drawMode;
            drawToggle.textContent = drawMode ? "Drawing Mode: ON" : "Toggle Draw Mode";
        });

        function createBox(x, y) {
            const width = lengthSlider.value;
            const height = heightSlider.value;

            // Create 4 sides of the box as dynamic bodies
            const top = Bodies.rectangle(x, y - height / 2, width, 10, { render: { fillStyle: color } });
            const bottom = Bodies.rectangle(x, y + height / 2, width, 10, { render: { fillStyle: color } });
            const left = Bodies.rectangle(x - width / 2, y, 10, height, { render: { fillStyle: color } });
            const right = Bodies.rectangle(x + width / 2, y, 10, height, { render: { fillStyle: color } });

            // Add gravity by making these bodies dynamic (removing isStatic)
            World.add(engine.world, [top, bottom, left, right]);

            // Create constraints between the sides of the box
            const topLeft = Constraint.create({
                bodyA: top,
                bodyB: left,
                stiffness: 0.9,
                render: { visible: false }
            });
            const topRight = Constraint.create({
                bodyA: top,
                bodyB: right,
                stiffness: 0.9,
                render: { visible: false }
            });
            const bottomLeft = Constraint.create({
                bodyA: bottom,
                bodyB: left,
                stiffness: 0.9,
                render: { visible: false }
            });
            const bottomRight = Constraint.create({
                bodyA: bottom,
                bodyB: right,
                stiffness: 0.9,
                render: { visible: false }
            });

            // Add constraints to the world
            World.add(engine.world, [topLeft, topRight, bottomLeft, bottomRight]);

            // Store the constraints in a list for later checks
            const constraints = [topLeft, topRight, bottomLeft, bottomRight];
            setInterval(() => checkForBreakConstraints(constraints), 100); // Check force periodically
        }
function checkForBreakConstraints(constraints) {
    const forceThreshold = 1000.0; // Higher threshold to avoid premature breaking

    constraints.forEach((constraint) => {
        const bodyA = constraint.bodyA;
        const bodyB = constraint.bodyB;

        // Calculate the relative velocity between the two bodies
        const velocityA = bodyA.velocity;
        const velocityB = bodyB.velocity;

        // Calculate the difference in velocities
        const velocityDifference = Vector.sub(velocityB, velocityA);
        const forceMagnitude = Vector.magnitude(velocityDifference);

        // If the force (velocity difference) exceeds the threshold, break the constraint
        if (forceMagnitude > forceThreshold) {
            // Apply a small force to separate the two bodies slightly
            const separationForce = Vector.mult(Vector.normalise(velocityDifference), 10);
            Body.applyForce(bodyA, bodyA.position, separationForce);
            Body.applyForce(bodyB, bodyB.position, Vector.neg(separationForce));

            World.remove(engine.world, constraint); // Remove constraint when force is too high

            // Optionally apply damping to the bodies to prevent them from bouncing off each other too much
            Body.set(bodyA, 'frictionAir', 0.05); // Adjust air friction (damping)
            Body.set(bodyB, 'frictionAir', 0.05);
        }
    });
}



        function explodeBomb(bomb) {
            const bombPosition = bomb.position;
            World.remove(engine.world, bomb);
            const objects = Matter.Composite.allBodies(engine.world);

            objects.forEach((body) => {
                if (!body.isStatic) {
                    const distance = Matter.Vector.magnitude(Matter.Vector.sub(body.position, bombPosition));
                    if (distance < 200) {
                        const forceMagnitude = 0.2 / (distance || 1);
                        const force = Matter.Vector.mult(Matter.Vector.normalise(Matter.Vector.sub(body.position, bombPosition)), forceMagnitude * 50.5);
                        Body.applyForce(body, body.position, force);
                    }
                }
            });
        }

        function resetSimulation() {
            World.clear(engine.world);
            Engine.clear(engine);
            render.canvas.width = render.canvas.width;
            World.add(engine.world, mouseConstraint);
            World.add(engine.world, ground);
        }

        Engine.run(engine);
        Render.run(render);
    </script>
</body>
</html>
